'use strict';


//  Обычный синтаксис {...} позволяет создать только один объект. Но зачастую нам
//  нужно создать множество похожих, однотипных объектов, таких как пользователи, элементы меню и так далее.
//
// Это можно сделать при помощи функции-конструктора и оператора "new".

//  Функции-конструкторы технически являются обычными функциями. Но есть два соглашения:
//
//  1 Имя функции-конструктора должно начинаться с большой буквы.
//  2 Функция-конструктор должна выполняться только с помощью оператора "new".
function User(name) {
    this.name = name;
    this.isAdmin = false;
}

let user = new User("Jack");

alert(user.name); // Jack
alert(user.isAdmin); // false

//  Когда функция вызывается как new User(...), происходит следующее:
//
//  Создаётся новый пустой объект, и он присваивается this.
//  Выполняется тело функции. Обычно оно модифицирует this, добавляя туда новые свойства.
//  Возвращается значение this.
//  Другими словами, new User(...) делает что-то вроде:
function UserMore(name) {
    // this = {};  (неявно)

    // добавляет свойства к this
    this.name = name;
    this.isAdmin = false;

    // return this;  (неявно)
}

//  Таким образом, let user = new User("Jack") возвращает тот же результат, что и:
let userSimple = {
    name: "Jack",
    isAdmin: false
};

//  Давайте ещё раз отметим – технически любая функция (кроме стрелочных функций, поскольку
//  у них нет this) может использоваться в качестве конструктора. Его можно запустить с
//  помощью new, и он выполнит выше указанный алгоритм. Подобные функции должны начинаться
//  с заглавной буквы – это общепринятое соглашение, чтобы было ясно, что функция должна вызываться с помощью «new».


//  Если в нашем коде присутствует большое количество строк, создающих один
//  сложный объект, то мы можем обернуть их в функцию-конструктор, которая будет немедленно вызвана, вот так:
// создаём функцию и сразу же вызываем её с помощью new
let userNew = new function () {
    this.name = "John";
    this.isAdmin = false;

    // ...другой код для создания пользователя
    // возможна любая сложная логика и инструкции
    // локальные переменные и так далее
};
//  Такой конструктор не может быть вызван снова, так как он нигде не сохраняется,
//  просто создаётся и тут же вызывается. Таким образом, этот трюк направлен
//  на инкапсуляцию кода, который создаёт отдельный объект, без возможности повторного использования в будущем.


//  Использование конструкторов для создания объектов даёт большую гибкость.
//  Функции-конструкторы могут иметь параметры, определяющие, как создавать объект и что в него записывать.
//
// Конечно, мы можем добавить к this не только свойства, но и методы.
//
// Например, new User(name) ниже создаёт объект с заданным name и методом sayHi:
function UserMethods(name) {
    this.name = name;

    this.sayHi = function () {
        alert("Меня зовут: " + this.name);
    };
}

let john = new UserMethods("John");

john.sayHi(); // Меня зовут: John

/*
john = {
   name: "John",
   sayHi: function() { ... }
}
*/


//  Если переменной user вообще нет, то user?.anything приведёт к ошибке:
//  ReferenceError: some is not defined
//  some?.address;


//  Как было сказано ранее, ?. немедленно останавливает вычисление, если левая часть не существует.
//
// Так что если после ?. есть какие-то вызовы функций или операции, то они не произойдут.
let address = null;
let x = 0;

address?.sayHi(x++); // нет "user", поэтому выполнение не достигает вызова sayHi и x++

alert(x); // 0, значение не увеличилось


//  Опциональная цепочка ?. — это не оператор, а специальная синтаксическая
//  конструкция, которая также работает с функциями и квадратными скобками.
//
//  Например, ?.() используется для вызова функции, которая может не существовать.
//
//  В приведённом ниже коде у некоторых наших пользователей есть метод admin, а у некоторых его нет:
let userAdmin = {
    admin() {
        alert("Я админ");
    }
};

let userGuest = {};

userAdmin.admin?.(); // Я админ

userGuest.admin?.(); // ничего не произойдет (такого метода нет)


//  Мы можем использовать ?. для безопасного чтения и удаления, но не для записи
//  Опциональная цепочка ?. не имеет смысла в левой части присваивания.
let someSome = null;

//  someSome?.name = "John"; // Ошибка, не работает
// то же самое что написать undefined = "John"


//  Синтаксис опциональной цепочки ?. имеет три формы:
//
//  1 obj?.prop – возвращает obj.prop если obj существует, в противном случае undefined.
//  2 obj?.[prop] – возвращает obj[prop] если obj существует, в противном случае undefined.
//  3 obj.method?.() – вызывает obj.method(), если obj.method существует, в противном случае возвращает undefined.
//  Как мы видим, все они просты и понятны в использовании. ?. проверяет левую часть на null/undefined и
//  позволяет продолжить вычисление, если это не так.
//
//  Цепочка ?. позволяет безопасно получать доступ к вложенным свойствам.
//
//  Тем не менее, мы должны использовать ?. осторожно, только там, где по логике кода допустимо, что
//  левая часть не существует. Чтобы он не скрывал от нас ошибки программирования, если они возникнут.
