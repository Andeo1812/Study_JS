'use strict';


//  Методы
//  Объект пользователя
let user = {
    name: "John",
    age: 30
};
user.sayHi = function () {
    alert("Hello!");
};
user.sayHi(); // Hello!

//  Так тоже можно
function sayGoodBuy() {
    alert("GoodBuy!");
};

user.sayGoodBuy = sayGoodBuy

//  Или
person = {
    sayPerson() {
        alert("person");
    }
}


//  Для доступа к информации внутри объекта метод может использовать ключевое слово this.
//  Значение this – это объект «перед точкой», который используется для вызова метода.
let userTest_ = {
    name: "John",
    age: 30,

    sayHi() {
        // "this" - это "текущий объект".
        alert(this.name);
    }
};

//  Технически также возможно получить доступ к объекту без ключевого слова this,
//  обратившись к нему через внешнюю переменную (в которой хранится ссылка на этот объект):
let admin = userTest_;
userTest_ = null; // перезапишем переменную для наглядности, теперь она не хранит ссылку на объект.

admin.sayHi(); // TypeError: Cannot read property 'name' of null
//  Если бы мы использовали this.name вместо userTest_.name внутри alert, тогда этот код бы сработал.


//  В JavaScript ключевое слово «this» ведёт себя иначе, чем в большинстве других языков программирования.
//  Его можно использовать в любой функции, даже если это не метод объекта.
//  В следующем примере нет синтаксической ошибки:
function someF() {
    alert(this.name);
}

let _user = {name: "John"};
let _admin = {name: "Admin"};

function sayHi() {
    alert(this.name);
}

// используем одну и ту же функцию в двух объектах
_user.f = sayHi;
_admin.f = sayHi;

// эти вызовы имеют  разное значение this
// "this" внутри функции - это объект "перед точкой"
_user.f(); // John  (this == user)
_admin.f(); // Admin  (this == admin)

_admin['f'](); // Admin (нет разницы между использованием точки или квадратных скобок для доступа к объекту)


//  Если вы до этого изучали другие языки программирования, то вы, вероятно, привыкли к идее
//  «фиксированного this» – когда методы, определённые в объекте, всегда имеют this, ссылающееся на этот объект.
//
// В JavaScript this является «свободным», его значение вычисляется в момент вызова метода
// и не зависит от того, где этот метод был объявлен, а скорее от того, какой объект
// вызывает метод (какой объект стоит «перед точкой»).
//
// Эта концепция вычисления this в момент исполнения имеет как свои плюсы, так и минусы.
// С одной стороны, функция может быть повторно использована в качестве метода у различных
// объектов (что повышает гибкость). С другой стороны, большая гибкость увеличивает вероятность ошибок.
//
// Здесь наша позиция заключается не в том, чтобы судить, является ли это архитектурное
// решение в языке хорошим или плохим. Скоро мы поймем, как с этим работать,
// как получить выгоду и избежать проблем.

//  У стрелочных функций нет «this»
//  Стрелочные функции особенные: у них нет своего «собственного» this. Если мы ссылаемся
//  на this внутри такой функции, то оно берётся из внешней «нормальной» функции.
// Например, здесь arrow() использует значение this из внешнего метода user.sayHi():
let _user_ = {
    firstName: "Ilya",
    sayHi() {
        let arrow = () => alert(this.firstName);
        arrow();
    }
};

_user_.sayHi(); // Ilya


//  Еще пример
let ladder = {
    step: 0,
    up() {
        this.step++;
        return this;
    },
    down() {
        this.step--;
        return this;
    },
    showStep() {
        alert(this.step);
        return this;
    }
};

ladder.up().up().down().showStep().down().showStep(); // показывает 1 затем 0
