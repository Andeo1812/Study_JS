'use strict';


//  В современном JavaScript существует два типа чисел:
//
//  1 Обычные числа в JavaScript хранятся в 64-битном формате IEEE-754, который
//  также называют «числа с плавающей точкой двойной точности» (double precision floating point numbers).
//  Это числа, которые мы будем использовать чаще всего. Мы поговорим о них в этой главе.
//  2 BigInt числа дают возможность работать с целыми числами произвольной длины.
//  Они нужны достаточно редко и используются в случаях, когда необходимо
//  работать со значениями более чем (253-1) или менее чем -(253-1). Так как BigInt числа
//  нужны достаточно редко, мы рассмотрим их в отдельной главе BigInt.
//  В данной главе мы рассмотрим только первый тип чисел: числа типа number.
//  Давайте глубже изучим, как с ними работать в JavaScript.


//  Представьте, что нам надо записать число 1 миллиард. Самый очевидный путь:
let billion = 1000000000;

//  В JavaScript можно использовать букву "e", чтобы укоротить запись числа.
//  Она добавляется к числу и заменяет указанное количество нулей:
let billionE = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей

alert(7.3e9);  // 7.3 миллиардов (7,300,000,000)


//  Шестнадцатеричные числа широко используются в JavaScript для представления цветов,
//  кодировки символов и многого другого. Естественно, есть короткий стиль записи: 0x,
//  после которого указывается число.
alert(0xff); // 255
alert(0xFF); // 255 (то же самое, регистр не имеет значения)


//  Не так часто используются двоичные и восьмеричные числа,
//  но они также поддерживаются 0b для двоичных и 0o для восьмеричных:
let a = 0b11111111; // бинарная форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255

alert(a == b); // true, с двух сторон число 255


//  Метод num.toString(base) возвращает строковое представление числа num в системе счисления base.
let num = 255;

alert(num.toString(16));  // ff
alert(num.toString(2));   // 11111111
//  base может варьироваться от 2 до 36 (по умолчанию 10).
//
//  Часто используемые:
//
//  base=16 — для шестнадцатеричного представления цвета, кодировки символов и т.д., цифры могут быть 0..9 или A..F.
//
//  base=2 — обычно используется для отладки побитовых операций, цифры 0 или 1.
//
//  base=36 — максимальное основание, цифры могут быть 0..9 или A..Z. То есть, используется весь
//  латинский алфавит для представления числа. Забавно, но можно использовать 36-разрядную
//  систему счисления для получения короткого представления большого числового идентификатора.
//  К примеру, для создания короткой ссылки. Для этого просто преобразуем его в 36-разрядную систему счисления:
alert(123456..toString(36)); // 2n9c


//  Внимание! Две точки в 123456..toString(36) это не опечатка. Если нам надо
//  вызвать метод непосредственно на числе, как toString в примере выше,
//  то нам надо поставить две точки .. после числа.
//
//  Если мы поставим одну точку: 123456.toString(36), тогда это будет ошибкой,
//  поскольку синтаксис JavaScript предполагает, что после первой точки начинается
//  десятичная часть. А если поставить две точки, то JavaScript понимает,
//  что десятичная часть отсутствует, и начинается метод.
//
//  Также можно записать как (123456).toString(36).


//  Одна из часто используемых операций при работе с числами – это округление.
//
//  В JavaScript есть несколько встроенных функций для работы с округлением:
//
//  Math.floor
//  Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.
//  Math.ceil
//  Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.
//  Math.round
//  Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.
//  Math.trunc (не поддерживается в Internet Explorer)
//  Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.
//  Ниже представлена таблица с различиями между функциями округления:
//
//              Math.floor	Math.ceil	Math.round	Math.trunc
// 3.1      	3	        4	        3	        3
// 3.6	        3	        4	        4	        3
// -1.1	        -2	        -1	        -1	        -1
// -1.6	        -2	        -1	        -2	        -1

//  Метод toFixed(n) округляет число до n знаков после запятой и возвращает строковое представление результата.
//  Округляет значение до ближайшего числа, как в большую, так и в меньшую сторону, аналогично методу Math.round:
//  Обратите внимание, что результатом toFixed является строка. Если десятичная часть короче,
//  чем необходима, будут добавлены нули в конец строки:
let num__ = 12.34;
alert(num__.toFixed(5)); // "12.34000", добавлены нули, чтобы получить 5 знаков после запятой
//  Мы можем преобразовать полученное значение в число, используя унарный оператор + или Number(),
//  пример с унарным оператором: +num.toFixed(5).


//  Неточные вычисления
//  Внутри JavaScript число представлено в виде 64-битного формата IEEE-754.
//  Для хранения числа используется 64 бита: 52 из них используется для хранения цифр,
//  11 для хранения положения десятичной точки и один бит отведён на хранение знака.
//
//  Если число слишком большое, оно переполнит 64-битное хранилище, JavaScript вернёт бесконечность:
alert(1e500); // Infinity

//  Наиболее часто встречающаяся ошибка при работе с числами в JavaScript – это потеря точности.
alert(0.1 + 0.2 == 0.3); // false

//  Можно ли обойти проблему? Конечно, наиболее надёжный способ — это округлить результат используя метод toFixed(n):
let sum = 0.1 + 0.2;
alert(+sum.toFixed(2)); // 0.3


//  Проверка: isFinite и isNaN
//  Помните эти специальные числовые значения?
//
//  * Infinity (и -Infinity) — особенное численное значение, которое ведёт себя в
//  точности как математическая бесконечность ∞.
//  * NaN представляет ошибку.
//  Эти числовые значения принадлежат типу number, но они не являются «обычными» числами,
//  поэтому есть функции для их проверки:
//
//  * isNaN(value) преобразует значение в число и проверяет является ли оно NaN:
alert(isNaN(NaN)); // true
alert(isNaN("str")); // true

//  Нужна ли нам эта функция? Разве не можем ли мы просто сравнить === NaN? К сожалению, нет.
//  Значение NaN уникально тем, что оно не является равным ни чему другому, даже самому себе:
alert(NaN === NaN); // false

//  * isFinite(value) преобразует аргумент в число и возвращает true,
//  если оно является обычным числом, т.е. не NaN/Infinity/-Infinity:
alert(isFinite("15")); // true
alert(isFinite("str")); // false, потому что специальное значение: NaN
alert(isFinite(Infinity)); // false, потому что специальное значение: Infinity

//  Иногда isFinite используется для проверки, содержится ли в строке число:
let ___num = +prompt("Enter a number", '');

//  вернёт true всегда, кроме ситуаций, когда аргумент - Infinity/-Infinity или не число
alert(isFinite(___num));
//  Помните, что пустая строка интерпретируется как 0 во всех числовых функциях, включая isFinite.


//  Методы Number.isNaN и Number.isFinite – это более «строгие» версии функций isNaN и isFinite.
//  Они не преобразуют аргумент в число, а наоборот – первым делом проверяют,
//  является ли аргумент числом (принадлежит ли он к типу number).
//  * Number.isNaN(value) возвращает true только в том случае, если аргумент принадлежит
//  к типу number и является NaN. Во всех остальных случаях возвращает false.
//  * Number.isFinite(value) возвращает true только в том случае, если аргумент
//  принадлежит к типу number и не является NaN/Infinity/-Infinity. Во всех остальных случаях возвращает false.
//  Не стоит считать Number.isNaN и Number.isFinite более «корректными» версиями функций
//  isNaN и isFinite. Это дополняющие друг-друга инструменты для разных задач.


//  Существует специальный метод Object.is, который сравнивает значения примерно
//  как ===, но более надёжен в двух особых ситуациях:
//
//  1 Работает с NaN: Object.is(NaN, NaN) === true, здесь он хорош.
//  2 Значения 0 и -0 разные: Object.is(0, -0) === false, это редко используется, но технически эти значения разные.
//  Во всех других случаях Object.is(a, b) идентичен a === b.
//
//  Этот способ сравнения часто используется в спецификации JavaScript.
//  Когда внутреннему алгоритму необходимо сравнить 2 значения на предмет
//  точного совпадения, он использует Object.is (Определение SameValue).


//  Для явного преобразования к числу можно использовать + или Number().
//  Если строка не является в точности числом, то результат будет NaN:
alert(+"100px"); // NaN

//  Единственное исключение — это пробелы в начале строки и в конце, они игнорируются.
//
//  В реальной жизни мы часто сталкиваемся со значениями у которых есть единица измерения,
//  например "100px" или "12pt" в CSS. Также во множестве стран символ валюты записывается
//  после номинала "19€". Так как нам получить числовое значение из таких строк?
//
//  Для этого есть parseInt и parseFloat.
//
//  Они «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают
//  полученное до ошибки число. Функция parseInt возвращает целое число, а
//  parseFloat возвращает число с плавающей точкой:
alert(parseInt('100px')); // 100
alert(parseFloat('12.5em')); // 12.5

alert(parseInt('12.3')); // 12, вернётся только целая часть
alert(parseFloat('12.3.4')); // 12.3, произойдёт остановка чтения на второй точке

//  Функции parseInt/parseFloat вернут NaN, если не смогли прочитать ни одну цифру:
alert(parseInt('a123')); // NaN, на первом символе происходит остановка чтения

//  Функция parseInt() имеет необязательный второй параметр.
//  Он определяет систему счисления, таким образом parseInt может также
//  читать строки с шестнадцатеричными числами, двоичными числами и т.д.:


//  В JavaScript встроен объект Math, который содержит различные математические функции и константы.
//
//  Несколько примеров:
//
//  Math.random()
//  Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1)

//  Math.max(a, b, c...) / Math.min(a, b, c...)
//  Возвращает наибольшее/наименьшее число из перечисленных аргументов.

// Math.pow(n, power)
// Возвращает число n, возведённое в степень power


//  Чтобы писать числа с большим количеством нулей:
//
//  * Используйте краткую форму записи чисел – "e", с указанным количеством нулей.
//  Например: 123e6 это 123 с 6-ю нулями 123000000.
//  * Отрицательное число после "e" приводит к делению числа на 1 с указанным количеством нулей.
//  Например: 123e-6 это 0.000123 (123 миллионных).

//  Для других систем счисления:
//
//  * Можно записывать числа сразу в шестнадцатеричной (0x), восьмеричной (0o) и бинарной (0b) системах счисления
//  * parseInt(str, base) преобразует строку в целое число в соответствии с указанной системой счисления: 2 ≤ base ≤ 36.
//  * num.toString(base) представляет число в строковом виде в указанной системе счисления base.

//  Для проверки на NaN и Infinity:
//
//  * isNaN(value) преобразует аргумент в число и проверяет, является ли оно NaN
//  * Number.isNaN(value) проверяет, является ли аргумент числом, и если да, то проверяет,
//  является ли оно NaN
//  * isFinite(value) преобразует аргумент в число и проверяет, что оно не является
//  NaN/Infinity/-Infinity
//  * Number.isFinite(value) проверяет, является ли аргумент числом, и если да, то проверяет,
//  что оно не является NaN/Infinity/-Infinity

//  Для преобразования значений типа 12pt и 100px в число:
//
//  * Используйте parseInt/parseFloat для «мягкого» преобразования строки в число, данные функции
//  по порядку считывают число из строки до тех пор пока не возникнет ошибка.

//  Для дробей:
//
//  * Используйте округления Math.floor, Math.ceil, Math.trunc, Math.round или num.toFixed(precision).
//  * Помните, что при работе с дробями происходит потеря точности.

//  Ещё больше математических функций:
//
//  Документация по объекту Math. Библиотека маленькая, но содержит всё самое важное.
