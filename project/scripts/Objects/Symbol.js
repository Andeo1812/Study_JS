"use strict";


//  «Символ» представляет собой уникальный идентификатор.
//  Создаём новый символ - id
let id = Symbol();


//  При создании, символу можно дать описание (также называемое имя), в основном использующееся для отладки кода:
//  Создаём символ id с описанием (именем) "id"
let id_ = Symbol("id");


//  Символы гарантированно уникальны. Даже если мы создадим множество символов с
//  одинаковым описанием, это всё равно будут разные символы.
//  Описание – это просто метка, которая ни на что не влияет.
//
// Например, вот два символа с одинаковым описанием – но они не равны:
let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2); // false


//  Большинство типов данных в JavaScript могут быть неявно
//  преобразованы в строку. Например, функция alert принимает
//  практически любое значение, автоматически преобразовывает
//  его в строку, а затем выводит это значение, не сообщая об
//  ошибке. Символы же особенные и не преобразуются автоматически.
//
// К примеру, alert ниже выдаст ошибку:
let __id = Symbol("id");
alert(__id); // TypeError: Cannot convert a Symbol value to a string

//  Это – языковая «защита» от путаницы, ведь строки и символы – принципиально разные типы
//  данных и не должны неконтролируемо преобразовываться друг в друга.
//
//  Если же мы действительно хотим вывести символ с помощью alert, то необходимо явно
//  преобразовать его с помощью метода .toString(), вот так:
alert(__id.toString()); // Symbol(id), теперь работает


//  Символы позволяют создавать «скрытые» свойства объектов,
//  к которым нельзя нечаянно обратиться и перезаписать их из других частей программы.
//
//  Например, мы работаем с объектами user, которые принадлежат
//  стороннему коду. Мы хотим добавить к ним идентификаторы.
let user = {
    name: "Вася"
};

let idTest = Symbol("id");

user[idTest] = 1;

alert(user[idTest]); // мы можем получить доступ к данным по ключу-символу


//  Так как объект user принадлежит стороннему коду, и этот код также работает с ним, то
//  нам не следует добавлять к нему какие-либо поля. Это небезопасно. Но к символу
//  сложно нечаянно обратиться, сторонний код вряд ли его вообще увидит, и, скорее всего,
//  добавление поля к объекту не вызовет никаких проблем.
//
//  Кроме того, предположим, что другой скрипт для каких-то своих целей хочет записать
//  собственный идентификатор в объект user. Этот скрипт может быть какой-то JavaScript-библиотекой,
//  абсолютно не связанной с нашим скриптом.
let idLib = Symbol("id");

user[idLib] = "Их идентификатор";

//  Конфликта между их и нашим идентификатором не будет,
//  так как символы всегда уникальны, даже если их имена совпадают.
//
//  А вот если бы мы использовали строку "id" вместо символа, то тогда был бы конфликт:
let userSome = {name: "Вася"};

// Объявляем в нашем скрипте свойство "id"
userSome.id = "Наш идентификатор";

// ...другой скрипт тоже хочет свой идентификатор...

userSome.id = "Их идентификатор"
//  Ой! Свойство перезаписано сторонней библиотекой!


//  Если мы хотим использовать символ при литеральном объявлении
//  объекта {...}, его необходимо заключить в квадратные скобки.
let idAlso = Symbol("id");

let userAlso = {
    name: "Вася",
    [idAlso]: 123 // просто "id: 123" не сработает
};


//  Свойства, чьи ключи – символы, не перебираются циклом for..in.
let idFor = Symbol("id");
let userFor = {
    name: "Вася",
    age: 30,
    [idFor]: 123
};

for (let key in userFor) alert(key); // name, age (свойства с ключом-символом нет среди перечисленных)

//  Хотя прямой доступ по символу работает
alert("Напрямую: " + userFor[idFor]);

//  Это – часть общего принципа «сокрытия символьных свойств». Если другая библиотека
//  или скрипт будут работать с нашим объектом, то при переборе они не получат
//  ненароком наше символьное свойство. Object.keys(user) также игнорирует символы.
//
//  А вот Object.assign, в отличие от цикла for..in, копирует и строковые, и символьные свойства:
let clone = Object.assign({}, idFor);

alert(clone[idFor]); // 123


//  Итак, как мы видели, обычно все символы уникальны, даже если их имена
//  совпадают. Но иногда мы наоборот хотим, чтобы символы с одинаковыми
//  именами были одной сущностью. Например, разные части нашего приложения
//  хотят получить доступ к символу "id", подразумевая именно одно и то же свойство.
//
//  Для этого существует глобальный реестр символов. Мы можем создавать в
//  нём символы и обращаться к ним позже, и при каждом обращении нам
//  гарантированно будет возвращаться один и тот же символ.
//
//  Для чтения (или, при отсутствии, создания) символа из реестра
//  используется вызов Symbol.for(key).

//  Читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан

//  Читаем его снова и записываем в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");

//  Проверяем -- это один и тот же символ
alert(id === idAgain); // true


//  Для глобальных символов, кроме Symbol.for(key), который ищет
//  символ по имени, существует обратный метод: Symbol.keyFor(sym), который,
//  наоборот, принимает глобальный символ и возвращает его имя.
//  Получаем символ по имени
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

//  Получаем имя по символу
alert(Symbol.keyFor(sym)); // name
alert(Symbol.keyFor(sym2)); // id

//  Внутри метода Symbol.keyFor используется глобальный реестр символов для
//  нахождения имени символа. Так что этот метод не будет работать для
//  неглобальных символов. Если символ неглобальный, метод не сможет его найти и вернёт undefined.
//
//  Впрочем, для любых символов доступно свойство description.
let globalSymbol = Symbol.for("name");
let localSymbol = Symbol("name");

alert(Symbol.keyFor(globalSymbol)); // name, глобальный символ
alert(Symbol.keyFor(localSymbol)); // undefined для неглобального символа

alert(localSymbol.description); // name
