//  Для работы кода в современном режиме
"use strict"


//  JavaScript - динамически типизированный язык
let message = "Hello"

message = 123123123  //  Это не ошибка


//  Кроме обычных чисел, существуют так называемые «специальные числовые значения»,
//  которые относятся к этому типу данных: Infinity, -Infinity и NaN.
//  alert( 1 / 0 ); // Infinity

//  Infinity представляет собой математическую бесконечность ∞. Это особое значение, которое больше любого числа.

//  NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:
//  alert( "не число" / 2 ); // NaN, такое деление является ошибкой

//  Значение NaN «прилипчиво». Любая математическая операция с NaN возвращает NaN:

//  alert( NaN + 1 ); // NaN
//  alert( 3 * NaN ); // NaN
//  alert( "не число" / 2 - 1 ); // NaN

//  Если где-то в математическом выражении есть NaN, то оно распространяется
//  на весь результат (есть только одно исключение: NaN ** 0 равно 1).


//  В JavaScript тип number не может безопасно работать с числами, большими, чем (2^53-1)
//  (т. е. 9007199254740991) или меньшими, чем -(2^53-1) для отрицательных чисел.
// Символ "n" в конце означает, что это BigInt
const bigInt = 1234567890123456789012345678901234567890n;


//  Строки
let str = "Привет";
let str2 = 'Одинарные кавычки тоже подойдут';
let phrase = `Обратные кавычки позволяют встраивать переменные ${str}`;

let name = "Иван";
// Вставим переменную
alert( `Привет, ${name}!` ); // Привет, Иван!

// Вставим выражение
alert( `результат: ${1 + 2}` ); // результат: 3


//  Существует bool
let nameFieldChecked = true; // да, поле отмечено
let ageFieldChecked = false; // нет, поле не отмечено

//  Булевые значения также могут быть результатом сравнений:
let isGreater = 4 > 1;
alert( isGreater ); // true (результатом сравнения будет "да")


//  Есть null
let age = null;
//  В JavaScript null не является «ссылкой на несуществующий объект»
//  или «нулевым указателем», как в некоторых других языках.


//  Специальное значение undefined также стоит особняком. Оно формирует тип из самого себя так же, как и null.
//  Оно означает, что «значение не было присвоено».
//  Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет undefined:
let age_;
alert(age_); // выведет "undefined"

//  Обычно null используется для присвоения переменной «пустого» или «неизвестного»
//  значения, а undefined – для проверок, была ли переменная назначена.


//  Тип object (объект) – особенный.
//  Все остальные типы называются «примитивными», потому что их значениями могут быть только
//  простые значения (будь то строка, или число, или что-то ещё). В объектах же хранят коллекции
//  данных или более сложные структуры.


//  Тип symbol (символ) используется для создания уникальных идентификаторов в объектах.
//  Мы упоминаем здесь о нём для полноты картины, изучим этот тип после объектов.


//  Оператор typeof возвращает тип аргумента. Это полезно, когда мы хотим
//  обрабатывать значения различных типов по-разному или просто хотим сделать проверку.
//  У него есть две синтаксические формы:
//  Синтаксис оператора: typeof x.
//  Синтаксис функции: typeof(x).
typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)


//  Math — это встроенный объект, который предоставляет математические операции и константы.
//  Мы рассмотрим его подробнее в главе Числа. Здесь он служит лишь примером объекта.
//  Результатом вызова typeof null является "object". Это официально признанная ошибка в typeof,
//  ведущая начало с времён создания JavaScript и сохранённая для совместимости. Конечно, null
//  не является объектом. Это специальное значение с отдельным типом.
//  Вызов typeof alert возвращает "function", потому что alert является функцией. Мы изучим функции в
//  следующих главах, где заодно увидим, что в JavaScript нет специального типа «функция».
//  Функции относятся к объектному типу. Но typeof обрабатывает их особым образом, возвращая "function".
//  Так тоже повелось от создания JavaScript. Формально это неверно, но может быть удобным на практике.
