'use strict';


//  В современном JavaScript существует два типа чисел:
//
//  1 Обычные числа в JavaScript хранятся в 64-битном формате IEEE-754, который
//  также называют «числа с плавающей точкой двойной точности» (double precision floating point numbers).
//  Это числа, которые мы будем использовать чаще всего. Мы поговорим о них в этой главе.
//  2 BigInt числа дают возможность работать с целыми числами произвольной длины.
//  Они нужны достаточно редко и используются в случаях, когда необходимо
//  работать со значениями более чем (253-1) или менее чем -(253-1). Так как BigInt числа
//  нужны достаточно редко, мы рассмотрим их в отдельной главе BigInt.
//  В данной главе мы рассмотрим только первый тип чисел: числа типа number.
//  Давайте глубже изучим, как с ними работать в JavaScript.


//  Представьте, что нам надо записать число 1 миллиард. Самый очевидный путь:
let billion = 1000000000;

//  В JavaScript можно использовать букву "e", чтобы укоротить запись числа.
//  Она добавляется к числу и заменяет указанное количество нулей:
let billionE = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей

alert(7.3e9);  // 7.3 миллиардов (7,300,000,000)


//  Шестнадцатеричные числа широко используются в JavaScript для представления цветов,
//  кодировки символов и многого другого. Естественно, есть короткий стиль записи: 0x,
//  после которого указывается число.
alert(0xff); // 255
alert(0xFF); // 255 (то же самое, регистр не имеет значения)


//  Не так часто используются двоичные и восьмеричные числа,
//  но они также поддерживаются 0b для двоичных и 0o для восьмеричных:
let a = 0b11111111; // бинарная форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255

alert(a == b); // true, с двух сторон число 255


//  Метод num.toString(base) возвращает строковое представление числа num в системе счисления base.
let num = 255;

alert(num.toString(16));  // ff
alert(num.toString(2));   // 11111111
//  base может варьироваться от 2 до 36 (по умолчанию 10).
//
//  Часто используемые:
//
//  base=16 — для шестнадцатеричного представления цвета, кодировки символов и т.д., цифры могут быть 0..9 или A..F.
//
//  base=2 — обычно используется для отладки побитовых операций, цифры 0 или 1.
//
//  base=36 — максимальное основание, цифры могут быть 0..9 или A..Z. То есть, используется весь
//  латинский алфавит для представления числа. Забавно, но можно использовать 36-разрядную
//  систему счисления для получения короткого представления большого числового идентификатора.
//  К примеру, для создания короткой ссылки. Для этого просто преобразуем его в 36-разрядную систему счисления:
alert(123456..toString(36)); // 2n9c


//  Внимание! Две точки в 123456..toString(36) это не опечатка. Если нам надо
//  вызвать метод непосредственно на числе, как toString в примере выше,
//  то нам надо поставить две точки .. после числа.
//
//  Если мы поставим одну точку: 123456.toString(36), тогда это будет ошибкой,
//  поскольку синтаксис JavaScript предполагает, что после первой точки начинается
//  десятичная часть. А если поставить две точки, то JavaScript понимает,
//  что десятичная часть отсутствует, и начинается метод.
//
//  Также можно записать как (123456).toString(36).


//  Одна из часто используемых операций при работе с числами – это округление.
//
//  В JavaScript есть несколько встроенных функций для работы с округлением:
//
//  Math.floor
//  Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.
//  Math.ceil
//  Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.
//  Math.round
//  Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.
//  Math.trunc (не поддерживается в Internet Explorer)
//  Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.
//  Ниже представлена таблица с различиями между функциями округления:
//
//              Math.floor	Math.ceil	Math.round	Math.trunc
// 3.1      	3	        4	        3	        3
// 3.6	        3	        4	        4	        3
// -1.1	        -2	        -1	        -1	        -1
// -1.6	        -2	        -1	        -2	        -1

//  Метод toFixed(n) округляет число до n знаков после запятой и возвращает строковое представление результата.
//  Округляет значение до ближайшего числа, как в большую, так и в меньшую сторону, аналогично методу Math.round:
//  Обратите внимание, что результатом toFixed является строка. Если десятичная часть короче,
//  чем необходима, будут добавлены нули в конец строки:
let num__ = 12.34;
alert(num__.toFixed(5)); // "12.34000", добавлены нули, чтобы получить 5 знаков после запятой
//  Мы можем преобразовать полученное значение в число, используя унарный оператор + или Number(),
//  пример с унарным оператором: +num.toFixed(5).


//  Неточные вычисления
//  Внутри JavaScript число представлено в виде 64-битного формата IEEE-754.
//  Для хранения числа используется 64 бита: 52 из них используется для хранения цифр,
//  11 для хранения положения десятичной точки и один бит отведён на хранение знака.
//
//  Если число слишком большое, оно переполнит 64-битное хранилище, JavaScript вернёт бесконечность:
alert(1e500); // Infinity

//  Наиболее часто встречающаяся ошибка при работе с числами в JavaScript – это потеря точности.
alert(0.1 + 0.2 == 0.3); // false

//  Можно ли обойти проблему? Конечно, наиболее надёжный способ — это округлить результат используя метод toFixed(n):
let sum = 0.1 + 0.2;
alert(+sum.toFixed(2)); // 0.3


//  Проверка: isFinite и isNaN
//  Помните эти специальные числовые значения?
//
//  * Infinity (и -Infinity) — особенное численное значение, которое ведёт себя в
//  точности как математическая бесконечность ∞.
//  * NaN представляет ошибку.
//  Эти числовые значения принадлежат типу number, но они не являются «обычными» числами,
//  поэтому есть функции для их проверки:
//
//  * isNaN(value) преобразует значение в число и проверяет является ли оно NaN:
alert(isNaN(NaN)); // true
alert(isNaN("str")); // true

//  Нужна ли нам эта функция? Разве не можем ли мы просто сравнить === NaN? К сожалению, нет.
//  Значение NaN уникально тем, что оно не является равным ни чему другому, даже самому себе:
alert(NaN === NaN); // false

//  * isFinite(value) преобразует аргумент в число и возвращает true,
//  если оно является обычным числом, т.е. не NaN/Infinity/-Infinity:
alert(isFinite("15")); // true
alert(isFinite("str")); // false, потому что специальное значение: NaN
alert(isFinite(Infinity)); // false, потому что специальное значение: Infinity